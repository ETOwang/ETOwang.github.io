<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>完整面试C++/Linux面试知识点详解</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- 引入代码高亮库 -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        // 初始化代码高亮
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });

        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#10b981',
                        accent: '#f59e0b',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Fira Code', 'Consolas', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        /* 基础与主题增强（放在 base 层） */
        @layer base {
            html { scroll-behavior: smooth; }
            body { background: linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%); }
        }

        @layer utilities {
            /* 容器与排版 */
            .container { max-width: 1200px; }
            .prose { color: #334155; }

            .card-shadow {
                box-shadow: 0 6px 14px -6px rgba(15, 23, 42, 0.15);
            }
            .card-hover {
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }
            .card-hover:hover {
                transform: translateY(-4px);
                box-shadow: 0 18px 30px -12px rgba(15, 23, 42, 0.25);
            }
            .card {
                position: relative;
                border: 1px solid rgba(148, 163, 184, 0.2);
                background: #fff;
            }
            .card h2 { letter-spacing: 0.2px; }
            .card h3 { color: #0f172a; }
            .card p { color: #334155; }
            .card ul { color: #334155; }
            .card ol { color: #334155; }

            /* 区块分隔，使信息层级更清晰 */
            .card .mb-4 + .mb-4 { border-top: 1px dashed rgba(148, 163, 184, 0.35); padding-top: 1rem; }

            /* 分类徽标（根据 data-category 自动显示） */
            .card::after {
                content: "";
                position: absolute;
                top: 14px; right: 16px;
                font-size: 11px;
                padding: 2px 8px;
                border-radius: 999px;
                background: #e2e8f0;
                color: #0f172a;
                letter-spacing: .3px;
                text-transform: none;
                opacity: .9;
            }
            .card[data-category="cpp"]::after { content: "C++"; background:#dbeafe; color:#1e3a8a; }
            .card[data-category="linux"]::after { content: "Linux"; background:#dcfce7; color:#14532d; }
            .card[data-category="network"]::after { content: "网络"; background:#fae8ff; color:#6b21a8; }
            .card[data-category="performance"]::after { content: "性能优化"; background:#fee2e2; color:#7f1d1d; }
            .card[data-category="interview"]::after { content: "面试题"; background:#fef9c3; color:#854d0e; }

            /* 过滤按钮样式优化 */
            .filter-btn {
                border: 1px solid rgba(148, 163, 184, 0.4);
                background: #f1f5f9;
                color: #0f172a;
                transition: all .15s ease;
            }
            .filter-btn:hover { background: #e2e8f0; }
            .filter-btn.active {
                background: linear-gradient(180deg, #3b82f6, #2563eb);
                color: #fff; border-color: transparent;
                box-shadow: 0 6px 18px -6px rgba(37, 99, 235, .35);
            }
            .filter-btn:focus-visible { outline: none; box-shadow: 0 0 0 3px rgba(37, 99, 235, .35); }
            .code-block {
                position: relative;
                border-radius: 0.375rem;
                margin: 0.5rem 0;
                overflow: hidden;
                overflow: hidden;
                border: 1px solid rgba(148, 163, 184, 0.25);
                background: #0b1220;
            }
            .code-block pre { margin: 0; }
            .code-block::before {
                content: "CODE";
                position: absolute;
                top: 0; left: 0;
                padding: 4px 10px;
                font-size: 10px; letter-spacing: .6px;
                color: #cbd5e1;
                background: rgba(148, 163, 184, 0.15);
                border-bottom-right-radius: 8px;
            }
            .copy-btn {
                position: absolute;
                top: 0.5rem;
                right: 0.5rem;
                padding: 0.25rem 0.5rem;
                background-color: rgba(15, 23, 42, 0.55);
                color: #e2e8f0;
                border: none;
                border-radius: 0.25rem;
                cursor: pointer;
                font-size: 0.75rem;
                transition: background-color 0.2s;
                z-index: 10;
            }
            .copy-btn::before {
                content: "\f0c5";
                font-family: FontAwesome;
                margin-right: 6px;
                font-size: 12px;
            }
            .copy-btn:hover { background-color: rgba(15, 23, 42, 0.8); }
            .copy-btn.copied { background-color: #10b981; }

            /* 顶部导航优化与滚动态 */
            header.sticky { backdrop-filter: saturate(1.2) blur(4px); background: rgba(255, 255, 255, .85); }
            header.scrolled { background: rgba(255, 255, 255, .95); box-shadow: 0 8px 20px -12px rgba(15, 23, 42, .35); }
            header h1 { letter-spacing: .3px; }
        }
    </style>
</head>

<body class="bg-gray-50 min-h-screen">
    <!-- 顶部导航 -->
    <header class="bg-white shadow-md sticky top-0 z-50">
        <div class="container mx-auto px-4 py-4">
            <h1 class="text-2xl md:text-3xl font-bold text-dark flex items-center">
                <i class="fa fa-code mr-2 text-primary"></i>
                C++/Linux面试知识点详解
            </h1>
            <div class="mt-3 flex flex-wrap gap-2">
                <button class="filter-btn active px-3 py-1 rounded-full bg-primary text-white text-sm"
                    data-filter="all">
                    全部知识点
                </button>
                <button class="filter-btn px-3 py-1 rounded-full bg-gray-200 text-dark text-sm" data-filter="cpp">
                    C++
                </button>
                <button class="filter-btn px-3 py-1 rounded-full bg-gray-200 text-dark text-sm" data-filter="linux">
                    Linux
                </button>
                <button class="filter-btn px-3 py-1 rounded-full bg-gray-200 text-dark text-sm" data-filter="network">
                    网络编程
                </button>
                <button class="filter-btn px-3 py-1 rounded-full bg-gray-200 text-dark text-sm"
                    data-filter="performance">
                    性能优化
                </button>
                <button class="filter-btn px-3 py-1 rounded-full bg-gray-200 text-dark text-sm" data-filter="interview">
                    面试题
                </button>
            </div>
        </div>
    </header>

    <!-- 主要内容区 -->
    <main class="container mx-auto px-4 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- 知识点卡片1 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="cpp">
                <h2 class="text-xl font-bold mb-4 text-primary">1. Copy On Write (COW) 机制</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">阐述写时复制（COW）原理，给出基于智能指针的 C++ 字符串实现，并说明 fork 的 COW 对内存与性能的影响。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">Copy On Write (写时复制)</span>
                        是一种优化技术，核心思想是延迟内存复制操作，只有当需要修改数据时才真正进行复制，从而减少不必要的内存开销。</p>

                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">在C++中实现COW字符串：</span>可以使用智能指针（如shared_ptr）管理底层字符数组，读操作时共享指针，写操作时检查引用计数，当计数大于1时进行复制。
                    </p>

                    <p class="text-gray-700"><span
                            class="font-medium">fork()的COW影响：</span>fork创建子进程时，内核不会立即复制父进程的内存，而是让父子进程共享同一份内存页表，标记为只读。当任一进程修改内存时，内核才会复制该内存页，这减少了进程创建的初始开销，但可能在后续写操作时带来额外延迟。
                    </p>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例：COW字符串类</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">class CowString {
private:
    // 共享数据结构
    struct Data {
        std::shared_ptr&lt;char[]&gt; buffer;
        size_t size;
        size_t capacity;
        
        Data(size_t cap) : capacity(cap), size(0) {
            buffer = std::make_shared&lt;char[]&gt;(cap + 1); // +1 for null terminator
            buffer[0] = '\0';
        }
    };
    
    std::shared_ptr&lt;Data&gt; data_;
    
    // 确保拥有独立副本（写时复制）
    void ensure_unique() {
        if (data_.use_count() &gt; 1) {
            auto new_data = std::make_shared&lt;Data&gt;(data_-&gt;capacity);
            std::strcpy(new_data->buffer.get(), data_->buffer.get());
            new_data->size = data_->size;
            data_ = new_data;
        }
    }
    
public:
    CowString() : data_(std::make_shared&lt;Data&gt;(15)) {} // 初始容量15
    
    // 拷贝构造 - 共享数据
    CowString(const CowString& other) : data_(other.data_) {}
    
    // 字符串赋值 - 写时复制
    CowString& operator=(const char* str) {
        ensure_unique(); // 确保修改不会影响其他共享者
        size_t len = std::strlen(str);
        if (len &gt; data_-&gt;capacity) {
            data_ = std::make_shared&lt;Data&gt;(len);
        }
        std::strcpy(data_->buffer.get(), str);
        data_->size = len;
        return *this;
    }
    
    // 字符修改 - 写时复制
    char& operator[](size_t index) {
        ensure_unique(); // 修改前确保拥有独立副本
        return data_->buffer[index];
    }
    
    // 只读访问 - 无需复制
    const char& operator[](size_t index) const {
        return data_->buffer[index];
    }
    
    // 其他方法...
};</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片2 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="cpp">
                <h2 class="text-xl font-bold mb-4 text-primary">2. 虚函数表内存布局</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">说明 GCC/Linux 环境下的虚函数表与对象内存布局，并给出 gdb/objdump/readelf 的验证方法。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">GCC中的虚函数表布局：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>每个包含虚函数的类（或其派生类）都有一个虚函数表（vtable），存储虚函数地址</li>
                        <li>类的每个实例对象的首地址存放一个指向虚函数表的指针（vptr）</li>
                        <li>单继承时，派生类虚表包含基类虚函数（未被重写的）和自身虚函数</li>
                        <li>多继承时，派生类对象会有多个vptr，分别对应不同基类的虚表</li>
                        <li>虚表中可能包含RTTI（运行时类型信息）指针，通常位于虚表的开始或结尾</li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">验证方法：</span></p>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li><span class="font-medium">使用gdb：</span>通过`p *object`查看对象布局，`info vtbl object`查看虚函数表，`x/10x
                            vtable_address`查看虚函数地址</li>
                        <li><span class="font-medium">使用objdump：</span>`objdump -s -j .rodata
                            executable`查看只读数据段，搜索"vtable for ClassName"查找虚表</li>
                        <li><span class="font-medium">使用readelf：</span>`readelf --symbols executable | grep
                            vtable`查找虚表符号</li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例与验证</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">// 示例类定义
class Base {
public:
    virtual void foo() {}
    virtual void bar() {}
};

class Derived : public Base {
public:
    void foo() override {} // 重写foo
    virtual void baz() {}  // 新增虚函数
};</code></pre>
                    </div>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto">// 使用gdb查看虚表的命令
(gdb) p derived_object
(gdb) info vtbl derived_object
(gdb) x/10x &derived_object  // 查看对象内存，首地址是vptr

// 使用objdump查看虚表
// objdump -s -j .rodata a.out | grep -A 10 "vtable for Derived"</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片3 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="network">
                <h2 class="text-xl font-bold mb-4 text-primary">3. 零拷贝(Zero-Copy)机制</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">阐述零拷贝原理、sendfile 的实现路径与适用场景，并与 read/write 的注意点进行对比。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">零拷贝概念：</span>零拷贝是一种IO操作优化技术，目的是减少数据在用户态和内核态之间的拷贝次数，以及CPU参与的数据搬运操作，从而提高数据传输效率。
                    </p>

                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">sendfile()实现原理：</span>sendfile()系统调用允许数据直接从文件描述符传输到套接字，整个过程完全在内核态完成，避免了数据在用户态和内核态之间的拷贝。它通过DMA（直接内存访问）将数据从磁盘读取到内核缓冲区，然后直接转发到网络协议栈，最后通过DMA发送到网卡。
                    </p>

                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">优势：</span>减少CPU占用、减少内存带宽消耗、降低缓存污染，特别适合大文件传输场景。</p>

                    <p class="text-gray-700"><span
                            class="font-medium">注意事项：</span>无法在传输过程中修改数据、需要文件描述符和套接字支持、小数据传输可能因系统调用开销抵消收益、不是所有文件系统和设备都支持。
                    </p>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例：使用sendfile传输文件</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;sys/sendfile.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;

class FileSender {
private:
    int sockfd_;
    
public:
    FileSender(int sockfd) : sockfd_(sockfd) {}
    
    // 使用sendfile发送文件
    ssize_t send_file(const char* filename) {
        int fd = open(filename, O_RDONLY);
        if (fd == -1) return -1;
        
        struct stat stat_buf;
        fstat(fd, &stat_buf);  // 获取文件信息
        
        off_t offset = 0;
        ssize_t total_sent = 0;
        ssize_t remaining = stat_buf.st_size;
        
        // 发送文件内容
        while (remaining > 0) {
            ssize_t sent = sendfile(sockfd_, fd, &offset, remaining);
            if (sent == -1) {
                close(fd);
                return -1;
            }
            total_sent += sent;
            remaining -= sent;
        }
        
        close(fd);
        return total_sent;
    }
    
    // 传统read/write方式（对比用）
    ssize_t send_file_traditional(const char* filename) {
        int fd = open(filename, O_RDONLY);
        if (fd == -1) return -1;
        
        char buffer[4096];
        ssize_t total_sent = 0;
        ssize_t n;
        
        while ((n = read(fd, buffer, sizeof(buffer))) > 0) {
            if (write(sockfd_, buffer, n) != n) {
                close(fd);
                return -1;
            }
            total_sent += n;
        }
        
        close(fd);
        return total_sent;
    }
};</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片4 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="linux">
                <h2 class="text-xl font-bold mb-4 text-primary">4. Linux信号(Signal)处理</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">说明常见 Linux 信号与处理策略，并给出优雅处理 SIGTERM/SIGINT 的实现。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">信号概念：</span>信号是Linux中进程间异步通信的一种机制，用于通知进程发生了某种事件。信号可以由内核、其他进程或进程自身产生。</p>

                    <p class="text-gray-700 mb-2"><span class="font-medium">常见需要处理的信号：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>SIGINT (2)：终端中断信号，通常由Ctrl+C触发</li>
                        <li>SIGTERM (15)：终止信号，请求进程退出</li>
                        <li>SIGQUIT (3)：终端退出信号，通常由Ctrl+\触发</li>
                        <li>SIGPIPE (13)：管道断裂信号，写入无人读取的管道</li>
                        <li>SIGHUP (1)：挂起信号，终端关闭时发送</li>
                    </ul>

                    <p class="text-gray-700"><span
                            class="font-medium">优雅处理SIGTERM和SIGINT：</span>不应在信号处理函数中执行复杂操作，而应设置一个退出标志。主程序定期检查该标志，当检测到退出请求时，执行必要的清理工作（关闭连接、释放资源、保存状态等），然后安全退出。
                    </p>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例：优雅退出实现</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;signal.h&gt;
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

class SignalHandler {
private:
    static std::atomic&lt;bool&gt; g_should_exit;
    
    static void signal_handler(int signum) {
        if (signum == SIGINT || signum == SIGTERM) {
            std::cout &lt;&lt; "\n收到退出信号，准备优雅退出..." &lt;&lt; std::endl;
            g_should_exit = true;
        }
    }
    
public:
    SignalHandler() {
        // 注册信号处理函数
        struct sigaction sa;
        sa.sa_handler = signal_handler;
        sigemptyset(&sa.sa_mask);
        sa.sa_flags = 0;
        
        sigaction(SIGINT, &sa, nullptr);
        sigaction(SIGTERM, &sa, nullptr);
    }
    
    static bool should_exit() {
        return g_should_exit;
    }
};

std::atomic&lt;bool&gt; SignalHandler::g_should_exit(false);

// 模拟服务清理工作
void cleanup() {
    std::cout << "执行清理工作..." << std::endl;
    // 关闭网络连接、释放资源、保存状态等
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "清理完成" << std::endl;
}

// 模拟服务主循环
void service_main() {
    SignalHandler handler;
    
    while (!SignalHandler::should_exit()) {
        std::cout << "服务运行中..." << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    
    // 执行清理
    cleanup();
}

int main() {
    service_main();
    std::cout << "服务已安全退出" << std::endl;
    return 0;
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片5 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="linux">
                <h2 class="text-xl font-bold mb-4 text-primary">5. Linux进程地址空间布局</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">概述 Linux 进程地址空间布局，并说明 new char[1] 实际分配为何大于 1 字节。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">Linux进程地址空间布局（从低地址到高地址）：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-4">
                        <li><span class="font-medium">文本段（Text Segment）：</span>存放可执行代码，只读，可共享</li>
                        <li><span class="font-medium">数据段（Data Segment）：</span>存放已初始化的全局变量和静态变量</li>
                        <li><span class="font-medium">BSS段：</span>存放未初始化的全局变量和静态变量，程序启动时会被清零</li>
                        <li><span class="font-medium">堆（Heap）：</span>动态内存分配区域，从低地址向高地址增长</li>
                        <li><span class="font-medium">内存映射区（Memory Mapping Segment）：</span>包括共享库、共享内存、文件映射等，从高地址向低地址增长
                        </li>
                        <li><span class="font-medium">栈（Stack）：</span>存放函数调用栈帧、局部变量等，从高地址向低地址增长</li>
                        <li><span class="font-medium">内核空间：</span>进程无法直接访问，存放内核代码和数据</li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">new char[1]的实际分配：</span></p>
                    <p class="text-gray-700">虽然逻辑上只请求1字节，但实际分配的内存会更多，原因包括：</p>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>内存分配器需要存储元数据（如块大小、是否已分配等）</li>
                        <li>内存对齐要求（通常是8字节或16字节对齐）</li>
                        <li>不同分配器的最小块大小（如glibc的malloc在64位系统上最小分配16字节）</li>
                        <li>因此，new char[1]实际可能分配16字节（1字节用户数据 + 15字节元数据和对齐填充）</li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例：查看内存布局</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

// 全局变量，位于数据段或BSS段
int global_init = 42;        // 数据段
int global_uninit;           // BSS段

int main() {
    // 局部变量，位于栈上
    int stack_var;
    
    // 动态分配，位于堆上
    char* heap_var = new char[1];
    
    // 打印各区域地址
    std::cout &lt;&lt; "代码段（main函数）: " &lt;&lt; reinterpret_cast&lt;void*&gt;(&amp;main) &lt;&lt; std::endl;
    std::cout &lt;&lt; "数据段（已初始化全局变量）: " &lt;&lt; reinterpret_cast&lt;void*&gt;(&amp;global_init) &lt;&lt; std::endl;
    std::cout &lt;&lt; "BSS段（未初始化全局变量）: " &lt;&lt; reinterpret_cast&lt;void*&gt;(&amp;global_uninit) &lt;&lt; std::endl;
    std::cout &lt;&lt; "堆（new char[1]）: " &lt;&lt; reinterpret_cast&lt;void*&gt;(heap_var) &lt;&lt; std::endl;
    std::cout &lt;&lt; "栈（局部变量）: " &lt;&lt; reinterpret_cast&lt;void*&gt;(&amp;stack_var) &lt;&lt; std::endl;
    
    delete[] heap_var;
    return 0;
}</code></pre>
                    </div>
                    <p class="text-gray-600 text-sm mt-2">运行程序后，可以观察到地址从低到高的分布符合上述布局顺序</p>
                </div>
            </div>

            <!-- 知识点卡片6 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="linux">
                <h2 class="text-xl font-bold mb-4 text-primary">6. Linux守护进程(Daemon)</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">定义守护进程，并给出标准 daemonize 步骤与代码实现。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">守护进程概念：</span>守护进程是在后台运行的特殊进程，独立于控制终端，通常在系统启动时开始运行，在系统关闭时终止。它们用于执行周期性任务或提供持续服务（如web服务器、数据库服务等）。
                    </p>

                    <p class="text-gray-700 mb-2"><span class="font-medium">创建守护进程的关键步骤：</span></p>
                    <ol class="list-decimal ml-5 text-gray-700">
                        <li><span class="font-medium">fork()：</span>创建子进程，然后父进程退出，使子进程成为孤儿进程，由init进程（或systemd）收养</li>
                        <li><span class="font-medium">setsid()：</span>创建新的会话，使进程脱离原终端控制，成为新会话的领头进程</li>
                        <li><span class="font-medium">忽略SIGHUP信号：</span>防止在会话领头进程终止时收到该信号</li>
                        <li><span class="font-medium">再次fork()：</span>（可选）确保进程不是会话领头进程，避免意外获得终端控制</li>
                        <li><span class="font-medium">chdir()：</span>改变工作目录（通常改为根目录/），避免占用可卸载的文件系统</li>
                        <li><span class="font-medium">umask()：</span>重置文件权限掩码，确保创建文件时的权限可控</li>
                        <li><span class="font-medium">关闭文件描述符：</span>关闭标准输入、输出和错误描述符（stdin, stdout, stderr）</li>
                        <li><span class="font-medium">重定向文件描述符：</span>（可选）将标准描述符重定向到/dev/null或日志文件</li>
                    </ol>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例：创建守护进程</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

class DaemonProcess {
public:
    static void daemonize() {
        // 第一步：fork并让父进程退出
        pid_t pid = fork();
        if (pid &lt; 0) {
            perror("fork failed");
            exit(EXIT_FAILURE);
        }
        if (pid &gt; 0) {
            exit(EXIT_SUCCESS); // 父进程退出
        }
        
        // 第二步：创建新会话
        if (setsid() &lt; 0) {
            perror("setsid failed");
            exit(EXIT_FAILURE);
        }
        
        // 忽略SIGHUP信号
        signal(SIGHUP, SIG_IGN);
        
        // 第三步：再次fork，确保不是会话领头进程
        pid = fork();
        if (pid &lt; 0) {
            perror("fork failed");
            exit(EXIT_FAILURE);
        }
        if (pid &gt; 0) {
            exit(EXIT_SUCCESS);
        }
        
        // 第四步：改变工作目录
        if (chdir("/") &lt; 0) {
            perror("chdir failed");
            exit(EXIT_FAILURE);
        }
        
        // 第五步：重置文件权限掩码
        umask(0);
        
        // 第六步：关闭所有文件描述符
        for (int fd = sysconf(_SC_OPEN_MAX); fd &gt;= 0; fd--) {
            close(fd);
        }
        
        // 第七步：重定向标准IO到/dev/null
        int devnull = open("/dev/null", O_RDWR);
        if (devnull &lt; 0) {
            exit(EXIT_FAILURE);
        }
        dup2(devnull, STDIN_FILENO);
        dup2(devnull, STDOUT_FILENO);
        dup2(devnull, STDERR_FILENO);
        close(devnull);
    }
};

// 守护进程主逻辑
void daemon_main() {
    // 这里实现守护进程的核心功能
    // 例如：周期性任务、服务监听等
    while (1) {
        sleep(60); // 模拟工作
    }
}

int main() {
    DaemonProcess::daemonize();
    daemon_main();
    return 0;
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片7 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="performance">
                <h2 class="text-xl font-bold mb-4 text-primary">7. CPU热点分析</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">如何定位 CPU 热点？列举常用性能分析工具及关键用法。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">CPU热点概念：</span>CPU热点指程序中消耗CPU时间最多的函数或代码片段，通常是性能优化的重点目标。</p>

                    <p class="text-gray-700 mb-2"><span class="font-medium">常用性能剖析工具：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span class="font-medium">perf：</span>Linux内核自带的性能分析工具，功能强大，支持多种事件类型</li>
                        <li><span class="font-medium">gprof：</span>GNU性能分析工具，适合简单程序，需要编译时添加-pg选项</li>
                        <li><span class="font-medium">gperftools：</span>Google性能工具集，包含CPU剖析器和堆分析器</li>
                        <li><span class="font-medium">Intel VTune：</span>Intel提供的性能分析工具，适合Intel平台深度优化</li>
                    </ul>

                    <p class="text-gray-700"><span
                            class="font-medium">perf工具使用方法：</span>perf是最常用的工具之一，支持采样、事件计数、调用图分析等功能，无需重新编译程序，使用灵活。</p>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">perf使用示例</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># 1. 基本CPU采样，记录程序运行期间的CPU事件
perf record -g ./my_program  # -g 记录调用栈

# 2. 查看分析结果
perf report  # 交互式查看热点函数

# 3. 实时查看系统级CPU热点
perf top

# 4. 针对特定PID进行采样
perf record -g -p 12345  # 12345是进程ID

# 5. 生成调用图
perf record -g --call-graph dwarf ./my_program
perf script | c++filt | gprof2dot -f perf | dot -Tpng -o callgraph.png</code></pre>
                    </div>

                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># gprof使用示例（需要重新编译）
g++ -pg -o my_program my_program.cpp  # 编译时添加-pg选项
./my_program  # 运行程序，生成gmon.out文件
gprof ./my_program gmon.out  # 分析结果
gprof ./my_program gmon.out --graph  # 生成图形化报告</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片8 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="performance">
                <h2 class="text-xl font-bold mb-4 text-primary">8. 内存错误检测</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">如何检测内存泄漏与非法访问？演示 Valgrind memcheck 的高效用法与注意点。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">内存问题类型：</span>包括内存泄漏（未释放不再使用的内存）、越界访问（读写超出分配范围的内存）、使用已释放内存（悬空指针）、重复释放内存等。
                    </p>

                    <p class="text-gray-700 mb-2"><span class="font-medium">常用检测工具：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span class="font-medium">Valgrind (memcheck)：</span>最常用的内存调试工具，能检测多种内存错误</li>
                        <li><span class="font-medium">AddressSanitizer (ASAN)：</span>编译器内置的内存错误检测器，速度比Valgrind快</li>
                        <li><span class="font-medium">LeakSanitizer (LSAN)：</span>专门检测内存泄漏的工具，常与ASAN一起使用</li>
                        <li><span class="font-medium">mtrace：</span>GNU C库提供的内存分配跟踪工具</li>
                    </ul>

                    <p class="text-gray-700"><span
                            class="font-medium">Valgrind与C++：</span>默认情况下，Valgrind可能无法完全理解C++的STL容器和智能指针，需要特殊处理才能获得准确结果。
                    </p>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">Valgrind使用示例</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># 基本用法：检测内存错误和泄漏
valgrind --leak-check=full --show-leak-kinds=all ./my_program

# 更详细的输出，包括每个泄漏的栈跟踪
valgrind --leak-check=full --track-origins=yes --verbose ./my_program

# 为C++程序提供更好的支持
valgrind --leak-check=full --gen-suppressions=all \
         --suppressions=/usr/lib/valgrind/default.supp \
         ./my_program</code></pre>
                    </div>

                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># 让Valgrind更好地支持STL和智能指针
# 1. 编译时启用调试符号
g++ -g -O0 -o my_program my_program.cpp

# 2. 使用最新版本的Valgrind（支持C++11及以上）
# 3. 创建自定义抑制文件处理已知的STL假阳性
# 创建一个suppressions.txt文件，包含类似以下内容：
# {
#    <STL_vector_leak>
#    Memcheck:Leak
#    ...
#    fun:operator new(unsigned long)
#    ...
# }

# 使用自定义抑制文件
valgrind --leak-check=full --suppressions=suppressions.txt ./my_program</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片9 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="linux">
                <h2 class="text-xl font-bold mb-4 text-primary">9. 文件描述符(FD)管理</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">解释文件描述符与配额限制，排查 “Too many open files” 的方法，并给出 RAII 封装示例。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span
                            class="font-medium">文件描述符概念：</span>文件描述符是Linux系统中用于标识打开文件的非负整数，是内核维护的打开文件表的索引。它不仅用于普通文件，还用于管道、套接字、设备等I/O资源。
                    </p>

                    <p class="text-gray-700 mb-2"><span class="font-medium">最大值限制：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>进程级限制：每个进程可以打开的最大文件描述符数，通过ulimit -n查看，默认通常是1024</li>
                        <li>系统级限制：整个系统可以打开的最大文件描述符总数，通过/proc/sys/fs/file-max查看</li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">"Too many open files"排查与解决：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>使用lsof -p <pid>查看特定进程打开的文件描述符</li>
                        <li>使用ulimit -n <number>临时修改进程限制</li>
                        <li>修改/etc/security/limits.conf永久调整用户级限制</li>
                        <li>修改/proc/sys/fs/file-max或/etc/sysctl.conf调整系统级限制</li>
                        <li>检查代码中是否存在文件描述符未关闭的泄漏问题</li>
                    </ul>

                    <p class="text-gray-700"><span
                            class="font-medium">RAII封装：</span>利用C++的RAII（资源获取即初始化）思想，将文件描述符封装在类中，构造函数打开资源，析构函数自动关闭资源，避免手动管理带来的泄漏风险。
                    </p>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例：RAII文件描述符封装</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;

class FileDescriptor {
private:
    int fd_;  // 存储文件描述符
    
    // 禁止拷贝构造和拷贝赋值
    FileDescriptor(const FileDescriptor&) = delete;
    FileDescriptor& operator=(const FileDescriptor&) = delete;
    
public:
    // 构造函数：打开文件并获取描述符
    FileDescriptor(const char* path, int flags, mode_t mode = 0644) {
        fd_ = open(path, flags, mode);
        if (fd_ == -1) {
            throw std::runtime_error("Failed to open file");
        }
    }
    
    // 移动构造函数
    FileDescriptor(FileDescriptor&& other) noexcept : fd_(other.fd_) {
        other.fd_ = -1;  // 转移所有权后，原对象不再拥有描述符
    }
    
    // 移动赋值运算符
    FileDescriptor& operator=(FileDescriptor&& other) noexcept {
        if (this != &other) {
            close();  // 关闭当前描述符
            fd_ = other.fd_;
            other.fd_ = -1;
        }
        return *this;
    }
    
    // 析构函数：自动关闭文件描述符
    ~FileDescriptor() {
        close();
    }
    
    // 关闭文件描述符
    void close() {
        if (fd_ != -1) {
            ::close(fd_);  // 调用系统close函数
            fd_ = -1;
        }
    }
    
    // 获取原始文件描述符
    int get() const {
        return fd_;
    }
    
    // 重载*运算符
    int operator*() const {
        return fd_;
    }
    
    // 判断是否有效
    explicit operator bool() const {
        return fd_ != -1;
    }
};

// 使用示例
void use_file() {
    try {
        // 打开文件，离开作用域时自动关闭
        FileDescriptor fd("example.txt", O_RDWR | O_CREAT, 0644);
        
        // 使用文件描述符进行操作
        if (fd) {
            // 执行读写操作...
        }
        
        // 不需要手动调用close()
    } catch (const std::exception& e) {
        // 处理错误
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片10 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="cpp">
                <h2 class="text-xl font-bold mb-4 text-primary">10. 多线程编程与死锁检测</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">对比 pthread 与 std::thread；在不终止进程的前提下，如何确认为死锁并定位。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">pthread与std::thread对比：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-4">
                        <li><span class="font-medium">联系：</span>
                            <ul class="list-circle ml-5">
                                <li>std::thread在Linux平台通常是pthread的封装</li>
                                <li>都遵循POSIX线程模型的基本概念（互斥锁、条件变量等）</li>
                                <li>可以混合使用（通过std::thread::native_handle()获取pthread_t）</li>
                            </ul>
                        </li>
                        <li><span class="font-medium">区别：</span>
                            <ul class="list-circle ml-5">
                                <li>pthread是C语言API，函数式接口；std::thread是C++类，面向对象接口</li>
                                <li>pthread需要手动管理线程生命周期（创建/销毁）；std::thread通过RAII自动管理</li>
                                <li>pthread错误通过返回值表示；std::thread通过异常机制报告错误</li>
                                <li>std::thread集成了C++特性（如lambda、函数对象），使用更方便</li>
                                <li>pthread可移植性限于POSIX系统；std::thread是C++标准，理论上可移植到所有C++支持平台</li>
                            </ul>
                        </li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">死锁检测方法：</span></p>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>使用pstack/pidof查看进程的线程调用栈，分析是否存在互相等待</li>
                        <li>使用gdb attach到进程，查看所有线程状态和调用栈</li>
                        <li>使用专门的工具如helgrind（Valgrind工具集）检测潜在的死锁</li>
                        <li>在程序中嵌入死锁检测机制（如定时检查线程状态）</li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">死锁检测示例</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># 使用pstack查看线程调用栈
pstack <pid>  # <pid>是进程ID

# 使用gdb检测死锁
gdb -p <pid>  # 附加到运行中的进程

# 在gdb中执行以下命令
(gdb) info threads  # 查看所有线程
(gdb) thread <thread-id>  # 切换到特定线程
(gdb) bt  # 查看当前线程的调用栈
(gdb) thread apply all bt  # 查看所有线程的调用栈

# 使用Valgrind的helgrind工具检测潜在死锁
valgrind --tool=helgrind ./my_program</code></pre>
                    </div>

                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

std::mutex mtx1, mtx2;

// 可能导致死锁的函数
void thread_func1() {
    std::lock_guard&lt;std::mutex&gt; lock1(mtx1);
    std::cout &lt;&lt; "Thread 1 locked mtx1" &lt;&lt; std::endl;
    
    // 模拟一些工作
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    std::lock_guard&lt;std::mutex&gt; lock2(mtx2);
    std::cout &lt;&lt; "Thread 1 locked mtx2" &lt;&lt; std::endl;
}

void thread_func2() {
    std::lock_guard&lt;std::mutex&gt; lock2(mtx2);
    std::cout &lt;&lt; "Thread 2 locked mtx2" &lt;&lt; std::endl;
    
    // 模拟一些工作
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    std::lock_guard&lt;std::mutex&gt; lock1(mtx1);
    std::cout &lt;&lt; "Thread 2 locked mtx1" &lt;&lt; std::endl;
}

int main() {
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);
    
    t1.join();
    t2.join();
    
    return 0;
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片11 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="network">
                <h2 class="text-xl font-bold mb-4 text-primary">11. IO多路复用与异步API</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">select/poll/epoll 是否异步？常用封装（libevent/libuv/asio）及 Reactor/Proactor 的区别与取舍。
                    </p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">同步与异步API：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-4">
                        <li>select、poll、epoll均为<span class="font-medium">同步API</span></li>
                        <li>它们只是提供了I/O多路复用能力，能同时监控多个文件描述符的状态</li>
                        <li>当I/O事件就绪时，仍需应用程序主动调用read/write等函数来完成实际I/O操作</li>
                        <li>Linux中没有真正意义上的异步I/O API，AIO（异步I/O）实现有限且不常用</li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">常用封装库：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span class="font-medium">libevent：</span>跨平台事件通知库，支持select、poll、epoll等，采用Reactor模式</li>
                        <li><span class="font-medium">libuv：</span>跨平台异步I/O库，Node.js底层依赖，采用Reactor模式</li>
                        <li><span class="font-medium">Boost.Asio/Asio：</span>C++网络库，支持多种I/O模型，可配置为Reactor或Proactor模式
                        </li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">Reactor与Proactor模式区别：</span></p>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li><span class="font-medium">Reactor模式：</span>
                            <ul class="list-circle ml-5">
                                <li>当I/O事件就绪时通知应用程序</li>
                                <li>由应用程序负责完成实际的读写操作</li>
                                <li>实现简单，性能良好，应用广泛</li>
                            </ul>
                        </li>
                        <li><span class="font-medium">Proactor模式：</span>
                            <ul class="list-circle ml-5">
                                <li>内核完成实际的读写操作后才通知应用程序</li>
                                <li>应用程序直接处理已经读取到缓冲区的数据</li>
                                <li>实现复杂，依赖操作系统支持，理论上更高效</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">代码示例：基于epoll的Reactor模式</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;sys/epoll.h&gt;
#include &lt;unistd.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

class Reactor {
private:
    int epoll_fd_;
    static const int MAX_EVENTS = 10;
    struct epoll_event events_[MAX_EVENTS];
    
public:
    Reactor() {
        epoll_fd_ = epoll_create1(0);
        if (epoll_fd_ == -1) {
            perror("epoll_create1");
            exit(EXIT_FAILURE);
        }
    }
    
    ~Reactor() {
        close(epoll_fd_);
    }
    
    // 添加文件描述符到监控列表
    void add_fd(int fd, uint32_t events) {
        struct epoll_event ev;
        ev.events = events;
        ev.data.fd = fd;
        if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {
            perror("epoll_ctl: add");
        }
    }
    
    // 等待事件
    int wait(int timeout = -1) {
        return epoll_wait(epoll_fd_, events_, MAX_EVENTS, timeout);
    }
    
    // 获取事件
    struct epoll_event get_event(int index) {
        return events_[index];
    }
};

int main() {
    Reactor reactor;
    
    // 添加标准输入到监控列表
    reactor.add_fd(STDIN_FILENO, EPOLLIN);
    
    while (true) {
        int num_events = reactor.wait();
        for (int i = 0; i &lt; num_events; ++i) {
            struct epoll_event ev = reactor.get_event(i);
            if (ev.events & EPOLLIN) {
                char buffer[1024];
                ssize_t n = read(ev.data.fd, buffer, sizeof(buffer));
                if (n &gt; 0) {
                    std::cout &lt;&lt; "Read: " &lt;&lt; std::string(buffer, n);
                }
            }
        }
    }
    
    return 0;
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片12 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">12. 二叉搜索树实现</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">实现支持插入、删除与查找的二叉搜索树。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">二叉搜索树特点：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>对于任意节点，左子树所有节点值小于该节点值</li>
                        <li>右子树所有节点值大于该节点值</li>
                        <li>左右子树也分别为二叉搜索树</li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">时间复杂度：</span></p>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>平均情况：查找、插入、删除均为O(log n)</li>
                        <li>最坏情况（退化为链表）：O(n)</li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">完整实现代码</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;iostream&gt;
#include &lt;memory&gt;

template&lt;typename T&gt;
class BST {
private:
    struct Node {
        T data;
        std::unique_ptr&lt;Node&gt; left;
        std::unique_ptr&lt;Node&gt; right;
        
        Node(const T& value) : data(value), left(nullptr), right(nullptr) {}
    };
    
    std::unique_ptr&lt;Node&gt; root;
    
    // 递归插入
    std::unique_ptr&lt;Node&gt; insert(std::unique_ptr&lt;Node&gt; node, const T& value) {
        if (!node) {
            return std::make_unique&lt;Node&gt;(value);
        }
        
        if (value &lt; node-&gt;data) {
            node-&gt;left = insert(std::move(node-&gt;left), value);
        } else if (value &gt; node-&gt;data) {
            node-&gt;right = insert(std::move(node-&gt;right), value);
        }
        // 相等时不插入重复值
        
        return node;
    }
    
    // 递归查找
    Node* search(Node* node, const T& value) const {
        if (!node || node->data == value) {
            return node;
        }
        
        if (value &lt; node-&gt;data) {
            return search(node-&gt;left.get(), value);
        } else {
            return search(node-&gt;right.get(), value);
        }
    }
    
    // 找到最小值节点
    Node* findMin(Node* node) const {
        while (node && node-&gt;left) {
            node = node-&gt;left.get();
        }
        return node;
    }
    
    // 递归删除
    std::unique_ptr&lt;Node&gt; remove(std::unique_ptr&lt;Node&gt; node, const T& value) {
        if (!node) {
            return nullptr;
        }
        
        if (value &lt; node-&gt;data) {
            node-&gt;left = remove(std::move(node-&gt;left), value);
        } else if (value &gt; node-&gt;data) {
            node-&gt;right = remove(std::move(node-&gt;right), value);
        } else {
            // 找到要删除的节点
            if (!node-&gt;left) {
                return std::move(node-&gt;right);
            } else if (!node-&gt;right) {
                return std::move(node-&gt;left);
            } else {
                // 节点有两个子节点
                Node* successor = findMin(node-&gt;right.get());
                node-&gt;data = successor-&gt;data;
                node-&gt;right = remove(std::move(node-&gt;right), successor-&gt;data);
            }
        }
        
        return node;
    }
    
    // 中序遍历
    void inorderTraversal(Node* node) const {
        if (node) {
            inorderTraversal(node-&gt;left.get());
            std::cout &lt;&lt; node-&gt;data &lt;&lt; " ";
            inorderTraversal(node-&gt;right.get());
        }
    }
    
public:
    BST() : root(nullptr) {}
    
    void insert(const T& value) {
        root = insert(std::move(root), value);
    }
    
    bool search(const T& value) const {
        return search(root.get(), value) != nullptr;
    }
    
    void remove(const T& value) {
        root = remove(std::move(root), value);
    }
    
    void printInOrder() const {
        inorderTraversal(root.get());
        std::cout &lt;&lt; std::endl;
    }
    
    bool empty() const {
        return root == nullptr;
    }
};

// 使用示例
int main() {
    BST&lt;int&gt; bst;
    
    // 插入操作
    bst.insert(50);
    bst.insert(30);
    bst.insert(70);
    bst.insert(20);
    bst.insert(40);
    bst.insert(60);
    bst.insert(80);
    
    // 中序遍历（应该输出有序序列）
    std::cout &lt;&lt; "中序遍历: ";
    bst.printInOrder();  // 输出：20 30 40 50 60 70 80
    
    // 查找操作
    std::cout &lt;&lt; "查找40: " &lt;&lt; (bst.search(40) ? "找到" : "未找到") &lt;&lt; std::endl;
    std::cout &lt;&lt; "查找25: " &lt;&lt; (bst.search(25) ? "找到" : "未找到") &lt;&lt; std::endl;
    
    // 删除操作
    bst.remove(30);
    std::cout &lt;&lt; "删除30后: ";
    bst.printInOrder();  // 输出：20 40 50 60 70 80
    
    return 0;
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片13 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">13. 无锁环形缓冲区（单生产者多消费者）</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">基于共享内存实现单生产者多消费者的无锁环形缓冲区。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">设计要点：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>使用原子操作保证线程安全</li>
                        <li>采用内存屏障确保正确的内存序</li>
                        <li>通过序列号机制避免ABA问题</li>
                        <li>使用缓存行对齐避免伪共享</li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">关键技术：</span></p>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>std::atomic用于原子操作</li>
                        <li>memory_order控制内存序</li>
                        <li>alignas确保缓存行对齐</li>
                        <li>共享内存映射</li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">完整实现代码</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;atomic&gt;
#include &lt;memory&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstring&gt;

template&lt;typename T, size_t Size&gt;
class LockFreeRingBuffer {
private:
    static constexpr size_t CACHE_LINE_SIZE = 64;
    
    struct alignas(CACHE_LINE_SIZE) Element {
        std::atomic&lt;uint64_t&gt; sequence{0};
        T data;
    };
    
    // 确保生产者和消费者计数器在不同缓存行
    alignas(CACHE_LINE_SIZE) std::atomic&lt;uint64_t&gt; write_sequence_{0};
    alignas(CACHE_LINE_SIZE) std::atomic&lt;uint64_t&gt; read_sequence_{0};
    
    Element* buffer_;
    size_t mask_;
    bool is_owner_;
    int shm_fd_;
    
public:
    // 创建共享内存环形缓冲区
    static std::unique_ptr&lt;LockFreeRingBuffer&gt; create(const char* name) {
        auto rb = std::unique_ptr&lt;LockFreeRingBuffer&gt;(new LockFreeRingBuffer());
        
        // 创建共享内存
        rb->shm_fd_ = shm_open(name, O_CREAT | O_RDWR, 0666);
        if (rb->shm_fd_ == -1) {
            return nullptr;
        }
        
        size_t total_size = sizeof(Element) * Size;
        if (ftruncate(rb->shm_fd_, total_size) == -1) {
            close(rb->shm_fd_);
            return nullptr;
        }
        
        // 映射共享内存
        void* addr = mmap(nullptr, total_size, PROT_READ | PROT_WRITE, 
                         MAP_SHARED, rb->shm_fd_, 0);
        if (addr == MAP_FAILED) {
            close(rb->shm_fd_);
            return nullptr;
        }
        
        rb-&gt;buffer_ = static_cast&lt;Element*&gt;(addr);
        rb-&gt;mask_ = Size - 1;
        rb-&gt;is_owner_ = true;
        
        // 初始化所有元素的序列号
        for (size_t i = 0; i &lt; Size; ++i) {
            rb->buffer_[i].sequence.store(i, std::memory_order_relaxed);
        }
        
        return rb;
    }
    
    // 连接到现有共享内存
    static std::unique_ptr&lt;LockFreeRingBuffer&gt; attach(const char* name) {
        auto rb = std::unique_ptr&lt;LockFreeRingBuffer&gt;(new LockFreeRingBuffer());
        
        rb->shm_fd_ = shm_open(name, O_RDWR, 0666);
        if (rb->shm_fd_ == -1) {
            return nullptr;
        }
        
        size_t total_size = sizeof(Element) * Size;
        void* addr = mmap(nullptr, total_size, PROT_READ | PROT_WRITE, 
                         MAP_SHARED, rb->shm_fd_, 0);
        if (addr == MAP_FAILED) {
            close(rb->shm_fd_);
            return nullptr;
        }
        
        rb-&gt;buffer_ = static_cast&lt;Element*&gt;(addr);
        rb-&gt;mask_ = Size - 1;
        rb-&gt;is_owner_ = false;
        
        return rb;
    }
    
    ~LockFreeRingBuffer() {
        if (buffer_) {
            munmap(buffer_, sizeof(Element) * Size);
        }
        if (shm_fd_ != -1) {
            close(shm_fd_);
        }
    }
    
    // 生产者写入数据
    bool write(const T& item) {
        uint64_t write_seq = write_sequence_.load(std::memory_order_relaxed);
        Element* element = &buffer_[write_seq & mask_];
        
        uint64_t sequence = element->sequence.load(std::memory_order_acquire);
        
        // 检查位置是否可写
        if (sequence != write_seq) {
            return false;  // 缓冲区满
        }
        
        // 写入数据
        element->data = item;
        
        // 更新序列号，允许消费者读取
        element->sequence.store(write_seq + 1, std::memory_order_release);
        
        // 更新写指针
        write_sequence_.store(write_seq + 1, std::memory_order_relaxed);
        
        return true;
    }
    
    // 消费者读取数据
    bool read(T& item) {
        uint64_t read_seq = read_sequence_.load(std::memory_order_relaxed);
        
        // 尝试获取下一个读取位置
        while (true) {
            Element* element = &buffer_[read_seq & mask_];
            uint64_t sequence = element->sequence.load(std::memory_order_acquire);
            
            // 检查是否有数据可读
            if (sequence != read_seq + 1) {
                return false;  // 没有数据或已被其他消费者读取
            }
            
            // 尝试原子性地更新读指针
            if (read_sequence_.compare_exchange_weak(read_seq, read_seq + 1, 
                                                   std::memory_order_relaxed)) {
                // 成功获得读取权限
                item = element->data;
                
                // 标记位置为可写
                element->sequence.store(read_seq + Size, std::memory_order_release);
                
                return true;
            }
            // CAS失败，重新获取读序列号
            read_seq = read_sequence_.load(std::memory_order_relaxed);
        }
    }
    
    // 获取当前可读元素数量（近似值）
    size_t size() const {
        uint64_t write_seq = write_sequence_.load(std::memory_order_acquire);
        uint64_t read_seq = read_sequence_.load(std::memory_order_acquire);
        return write_seq - read_seq;
    }
    
    bool empty() const {
        return size() == 0;
    }
    
    bool full() const {
        return size() >= Size;
    }
    
private:
    LockFreeRingBuffer() : buffer_(nullptr), mask_(0), is_owner_(false), shm_fd_(-1) {}
};

// 使用示例
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;

void producer_example() {
    auto buffer = LockFreeRingBuffer&lt;int, 1024&gt;::create("/test_ring_buffer");
    if (!buffer) {
        std::cerr &lt;&lt; "Failed to create ring buffer" &lt;&lt; std::endl;
        return;
    }
    
    // 生产者线程
    std::thread producer([&buffer]() {
        for (int i = 0; i < 10000; ++i) {
            while (!buffer->write(i)) {
                std::this_thread::yield();  // 缓冲区满时让出CPU
            }
            
            if (i % 1000 == 0) {
                std::cout &lt;&lt; "Produced: " &lt;&lt; i &lt;&lt; std::endl;
            }
        }
        std::cout &lt;&lt; "Producer finished" &lt;&lt; std::endl;
    });
    
    // 多个消费者线程
    std::vector&lt;std::thread&gt; consumers;
    std::atomic&lt;int&gt; total_consumed{0};
    
    for (int i = 0; i < 3; ++i) {
        consumers.emplace_back([&buffer, &total_consumed, i]() {
            int local_count = 0;
            int data;
            
            while (total_consumed.load() &lt; 10000) {
                if (buffer-&gt;read(data)) {
                    local_count++;
                    total_consumed.fetch_add(1);
                } else {
                    std::this_thread::yield();
                }
            }
            
            std::cout &lt;&lt; "Consumer " &lt;&lt; i &lt;&lt; " consumed: " &lt;&lt; local_count &lt;&lt; std::endl;
        });
    }
    
    producer.join();
    for (auto& consumer : consumers) {
        consumer.join();
    }
    
    std::cout &lt;&lt; "Total consumed: " &lt;&lt; total_consumed.load() &lt;&lt; std::endl;
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片14 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">14. 高效矩阵乘法实现</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">从算法、缓存、SIMD 与并行角度优化矩阵乘法的 C++ 实现。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">详细解释</h3>
                    <p class="text-gray-700 mb-2"><span class="font-medium">优化策略：</span></p>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span class="font-medium">算法优化：</span>分块矩阵乘法、Strassen算法</li>
                        <li><span class="font-medium">缓存优化：</span>循环重排序、数据预取、内存局部性</li>
                        <li><span class="font-medium">指令集优化：</span>SIMD指令（AVX、SSE）</li>
                        <li><span class="font-medium">并行优化：</span>OpenMP、多线程、GPU计算</li>
                    </ul>

                    <p class="text-gray-700 mb-2"><span class="font-medium">性能提升点：</span></p>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>减少缓存缺失（分块计算）</li>
                        <li>提高指令吞吐量（向量化）</li>
                        <li>利用多核并行（线程池）</li>
                        <li>减少内存访问开销</li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">多种优化实现</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;vector&gt;
#include &lt;immintrin.h&gt;  // AVX指令集
#include &lt;omp.h&gt;        // OpenMP
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;

class MatrixMultiplier {
public:
    using Matrix = std::vector&lt;std::vector&lt;float&gt;&gt;;
    
    // 1. 基础版本
    static Matrix multiply_basic(const Matrix& A, const Matrix& B) {
        size_t n = A.size();
        size_t m = A[0].size();
        size_t p = B[0].size();
        
        Matrix C(n, std::vector&lt;float&gt;(p, 0.0f));
        
        for (size_t i = 0; i &lt; n; ++i) {
            for (size_t j = 0; j &lt; p; ++j) {
                for (size_t k = 0; k &lt; m; ++k) {
                    C[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        
        return C;
    }
    
    // 2. 缓存优化版本（分块矩阵乘法）
    static Matrix multiply_blocked(const Matrix& A, const Matrix& B, size_t block_size = 64) {
        size_t n = A.size();
        size_t m = A[0].size();
        size_t p = B[0].size();
        
        Matrix C(n, std::vector&lt;float&gt;(p, 0.0f));
        
        for (size_t ii = 0; ii &lt; n; ii += block_size) {
            for (size_t jj = 0; jj &lt; p; jj += block_size) {
                for (size_t kk = 0; kk &lt; m; kk += block_size) {
                    
                    size_t i_end = std::min(ii + block_size, n);
                    size_t j_end = std::min(jj + block_size, p);
                    size_t k_end = std::min(kk + block_size, m);
                    
                    // 计算当前块
                    for (size_t i = ii; i &lt; i_end; ++i) {
                        for (size_t j = jj; j &lt; j_end; ++j) {
                            float sum = C[i][j];
                            for (size_t k = kk; k &lt; k_end; ++k) {
                                sum += A[i][k] * B[k][j];
                            }
                            C[i][j] = sum;
                        }
                    }
                }
            }
        }
        
        return C;
    }
    
    // 3. SIMD优化版本（AVX）
    static Matrix multiply_avx(const Matrix& A, const Matrix& B) {
        size_t n = A.size();
        size_t m = A[0].size();
        size_t p = B[0].size();
        
        Matrix C(n, std::vector&lt;float&gt;(p, 0.0f));
        
        // 确保p是8的倍数（AVX一次处理8个float）
        size_t p_aligned = (p / 8) * 8;
        
        for (size_t i = 0; i &lt; n; ++i) {
            for (size_t k = 0; k &lt; m; ++k) {
                __m256 a_ik = _mm256_broadcast_ss(&A[i][k]);
                
                // 处理对齐的部分
                for (size_t j = 0; j &lt; p_aligned; j += 8) {
                    __m256 b_kj = _mm256_loadu_ps(&B[k][j]);
                    __m256 c_ij = _mm256_loadu_ps(&C[i][j]);
                    
                    __m256 result = _mm256_fmadd_ps(a_ik, b_kj, c_ij);
                    _mm256_storeu_ps(&C[i][j], result);
                }
                
                // 处理剩余部分
                for (size_t j = p_aligned; j &lt; p; ++j) {
                    C[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        
        return C;
    }
    
    // 4. OpenMP并行版本
    static Matrix multiply_parallel(const Matrix& A, const Matrix& B) {
        size_t n = A.size();
        size_t m = A[0].size();
        size_t p = B[0].size();
        
        Matrix C(n, std::vector&lt;float&gt;(p, 0.0f));
        
        #pragma omp parallel for
        for (size_t i = 0; i &lt; n; ++i) {
            for (size_t j = 0; j &lt; p; ++j) {
                float sum = 0.0f;
                for (size_t k = 0; k &lt; m; ++k) {
                    sum += A[i][k] * B[k][j];
                }
                C[i][j] = sum;
            }
        }
        
        return C;
    }
    
    // 5. 终极优化版本（分块+SIMD+并行）
    static Matrix multiply_optimized(const Matrix& A, const Matrix& B, size_t block_size = 64) {
        size_t n = A.size();
        size_t m = A[0].size();
        size_t p = B[0].size();
        
        Matrix C(n, std::vector&lt;float&gt;(p, 0.0f));
        
        #pragma omp parallel for
        for (size_t ii = 0; ii &lt; n; ii += block_size) {
            for (size_t jj = 0; jj &lt; p; jj += block_size) {
                for (size_t kk = 0; kk &lt; m; kk += block_size) {
                    
                    size_t i_end = std::min(ii + block_size, n);
                    size_t j_end = std::min(jj + block_size, p);
                    size_t k_end = std::min(kk + block_size, m);
                    
                    // 每个块内使用SIMD优化
                    for (size_t i = ii; i &lt; i_end; ++i) {
                        for (size_t k = kk; k &lt; k_end; ++k) {
                            __m256 a_ik = _mm256_broadcast_ss(&A[i][k]);
                            
                            size_t j_aligned = jj + ((j_end - jj) / 8) * 8;
                            
                            // SIMD处理
                            for (size_t j = jj; j &lt; j_aligned; j += 8) {
                                __m256 b_kj = _mm256_loadu_ps(&B[k][j]);
                                __m256 c_ij = _mm256_loadu_ps(&C[i][j]);
                                
                                __m256 result = _mm256_fmadd_ps(a_ik, b_kj, c_ij);
                                _mm256_storeu_ps(&C[i][j], result);
                            }
                            
                            // 处理剩余元素
                            for (size_t j = j_aligned; j &lt; j_end; ++j) {
                                C[i][j] += A[i][k] * B[k][j];
                            }
                        }
                    }
                }
            }
        }
        
        return C;
    }
};

// 性能测试
class MatrixBenchmark {
public:
    static void benchmark_all(size_t size) {
        // 生成测试矩阵
        auto A = generate_matrix(size, size);
        auto B = generate_matrix(size, size);
        
        std::cout << "Matrix size: " << size << "x" << size << std::endl;
        
        // 测试不同版本
        benchmark_method("Basic", [&]() { 
            return MatrixMultiplier::multiply_basic(A, B); 
        });
        
        benchmark_method("Blocked", [&]() { 
            return MatrixMultiplier::multiply_blocked(A, B, 64); 
        });
        
        benchmark_method("AVX", [&]() { 
            return MatrixMultiplier::multiply_avx(A, B); 
        });
        
        benchmark_method("Parallel", [&]() { 
            return MatrixMultiplier::multiply_parallel(A, B); 
        });
        
        benchmark_method("Optimized", [&]() { 
            return MatrixMultiplier::multiply_optimized(A, B, 64); 
        });
    }
    
private:
    static MatrixMultiplier::Matrix generate_matrix(size_t rows, size_t cols) {
        MatrixMultiplier::Matrix matrix(rows, std::vector&lt;float&gt;(cols));
        for (size_t i = 0; i &lt; rows; ++i) {
            for (size_t j = 0; j &lt; cols; ++j) {
                matrix[i][j] = static_cast&lt;float&gt;(rand()) / RAND_MAX;
            }
        }
        return matrix;
    }
    
    template&lt;typename Func&gt;
    static void benchmark_method(const std::string&amp; name, Func func) {
        auto start = std::chrono::high_resolution_clock::now();
        auto result = func();
        auto end = std::chrono::high_resolution_clock::now();
        
        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);
        std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; duration.count() &lt;&lt; " ms" &lt;&lt; std::endl;
    }
};

// 使用示例
int main() {
    // 设置OpenMP线程数
    omp_set_num_threads(std::thread::hardware_concurrency());
    
    std::cout &lt;&lt; "Matrix Multiplication Benchmark" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Using " &lt;&lt; omp_get_max_threads() &lt;&lt; " threads" &lt;&lt; std::endl;
    
    // 测试不同大小的矩阵
    for (size_t size : {128, 256, 512}) {
        std::cout &lt;&lt; "\n";
        MatrixBenchmark::benchmark_all(size);
    }
    
    return 0;
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片15 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">15. 实现一个 shared_ptr（线程安全引用计数）</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">实现简化版 shared_ptr：控制块、原子引用计数、拷贝/移动、别名构造与线程安全边界。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">关键点与设计</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>控制块（Control Block）单独保存<strong>原子</strong>引用计数与删除器；对象指针与控制块分离，便于别名与自定义删除器。</li>
                        <li>引用计数递增/递减需使用std::atomic，保证多线程下<strong>引用计数线程安全</strong>（对象本身不保证线程安全）。</li>
                        <li>拷贝构造/赋值：增加计数；移动构造/赋值：转移指针与控制块，源置空。</li>
                        <li>析构：计数归零时调用删除器删除对象并释放控制块。</li>
                        <li>别名构造：共享同一控制块但指向子对象（如容器元素/成员）。</li>
                        <li>与weak_ptr：生产级实现还需弱计数避免ABA与控制块过早释放（此处省略）。</li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">参考实现（教学用，含别名构造）</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;atomic&gt;
#include &lt;utility&gt;
#include &lt;cstddef&gt;

struct DefaultDeleterBase {
    virtual void destroy(void* p) noexcept = 0;
    virtual ~DefaultDeleterBase() = default;
};

template&lt;typename T&gt;
struct DefaultDeleter : DefaultDeleterBase {
    void destroy(void* p) noexcept override { delete static_cast&lt;T*&gt;(p); }
};

struct ControlBlock {
    std::atomic&lt;long&gt; strong{1};
    DefaultDeleterBase* deleter{nullptr};
};

template&lt;typename T&gt;
class SharedPtr {
public:
    // 构造：接管裸指针
    explicit SharedPtr(T* ptr = nullptr)
        : ptr_(ptr) {
        if (ptr_) {
            cb_ = new ControlBlock{1, new DefaultDeleter&lt;T&gt;()};
        }
    }

    // 自定义删除器构造
    template&lt;typename Deleter&gt;
    SharedPtr(T* ptr, Deleter d) : ptr_(ptr) {
        if (ptr_) {
            struct D : DefaultDeleterBase {
                Deleter del;
                explicit D(Deleter dd) : del(std::move(dd)) {}
                void destroy(void* p) noexcept override { del(static_cast&lt;T*&gt;(p)); }
            };
            cb_ = new ControlBlock{1, new D(std::move(d))};
        }
    }

    // 别名构造：共享控制块但指向别的地址（如成员）
    template&lt;typename U&gt;
    SharedPtr(const SharedPtr&lt;U&gt;&amp; other, T* alias) noexcept
        : ptr_(alias), cb_(other.cb_) {
        inc();
    }

    // 拷贝构造
    SharedPtr(const SharedPtr&amp; other) noexcept
        : ptr_(other.ptr_), cb_(other.cb_) { inc(); }

    // 移动构造
    SharedPtr(SharedPtr&amp;&amp; other) noexcept
        : ptr_(other.ptr_), cb_(other.cb_) {
        other.ptr_ = nullptr; other.cb_ = nullptr;
    }

    // 拷贝赋值
    SharedPtr&amp; operator=(const SharedPtr&amp; other) noexcept {
        if (this != &amp;other) { release(); ptr_ = other.ptr_; cb_ = other.cb_; inc(); }
        return *this;
    }

    // 移动赋值
    SharedPtr&amp; operator=(SharedPtr&amp;&amp; other) noexcept {
        if (this != &amp;other) { release(); ptr_ = other.ptr_; cb_ = other.cb_; other.ptr_ = nullptr; other.cb_ = nullptr; }
        return *this;
    }

    ~SharedPtr() { release(); }

    void reset() noexcept { release(); }
    void reset(T* p) { release(); *this = SharedPtr(p); }

    T* get() const noexcept { return ptr_; }
    T&amp; operator*() const noexcept { return *ptr_; }
    T* operator-&gt;() const noexcept { return ptr_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }
    long use_count() const noexcept { return cb_ ? cb_-&gt;strong.load(std::memory_order_acquire) : 0; }

private:
    template&lt;typename U&gt; friend class SharedPtr;
    T* ptr_ = nullptr;
    ControlBlock* cb_ = nullptr;

    void inc() noexcept { if (cb_) cb_-&gt;strong.fetch_add(1, std::memory_order_acq_rel); }
    void release() noexcept {
        if (!cb_) return;
        if (cb_-&gt;strong.fetch_sub(1, std::memory_order_acq_rel) == 1) {
            // 最后一个强引用，销毁对象与控制块
            cb_-&gt;deleter-&gt;destroy(ptr_);
            delete cb_-&gt;deleter;
            delete cb_;
        }
        ptr_ = nullptr; cb_ = nullptr;
    }
};

// 使用示例
struct Node { int x; };
int main() {
    SharedPtr&lt;Node&gt; p(new Node{42});
    auto q = p; // 引用计数+1
    SharedPtr&lt;int&gt; alias(p, &amp;p-&gt;x); // 别名构造，控制块共享
    return alias.use_count() &gt; 0 ? 0 : 1;
}</code></pre>
                    </div>
                    <p class="text-gray-600 text-sm mt-2">
                        注意：此实现仅保证<strong>引用计数</strong>层面的并发安全；对象本身读写需额外同步。生产级还应包含弱计数、类型擦除的删除器优化、make_shared优化（对象与控制块同配）等。
                    </p>
                </div>
            </div>

            <!-- 知识点卡片16 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">16. 实现归并排序（稳定，O(n log n)）</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">实现稳定的归并排序（时间 O(n log n)、空间 O(n)）。</p>
                </div>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">思路与性质</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>分治：递归拆分为左右子序列，分别排序后合并。</li>
                        <li>稳定性：合并时遇到相等元素保持先后顺序即可。</li>
                        <li>复杂度：时间O(n log n)，额外空间O(n)用于临时缓冲。</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">参考实现</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;vector&gt;
#include &lt;functional&gt;

template&lt;typename T, typename Compare = std::less&lt;T&gt;&gt;
void merge_sort(std::vector&lt;T&gt;&amp; a, Compare comp = Compare{}) {
    std::vector&lt;T&gt; buf(a.size());
    std::function&lt;void(size_t,size_t)&gt; sort_impl = [&](size_t l, size_t r){
        if (r - l &lt;= 1) return;
        size_t m = l + (r - l) / 2;
        sort_impl(l, m);
        sort_impl(m, r);
        // 合并 [l,m) 与 [m,r)
        size_t i = l, j = m, k = l;
        while (i &lt; m &amp;&amp; j &lt; r) {
            if (comp(a[i], a[j]) || (!comp(a[j], a[i]))) { // 稳定：相等时取左侧
                buf[k++] = a[i++];
            } else {
                buf[k++] = a[j++];
            }
        }
        while (i &lt; m) buf[k++] = a[i++];
        while (j &lt; r) buf[k++] = a[j++];
        for (size_t t = l; t &lt; r; ++t) a[t] = buf[t];
    };
    sort_impl(0, a.size());
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片17 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">17. for循环中使用erase的坑与安全写法</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">for 循环中使用 erase 的风险与安全写法。</p>
                </div>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">要点</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span
                                class="font-medium">迭代器失效：</span>vector、deque在erase后，<em>被删位置及后续</em>迭代器全部失效；list、forward_list只使被删元素的迭代器失效；map/unordered_*
                            只使被删元素失效。</li>
                        <li>安全写法：使用erase返回的迭代器继续遍历，或使用erase-remove惯用法（序列容器）。</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">示例：安全遍历删除</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;unordered_map&gt;

// 序列容器：用返回迭代器
void erase_in_vector(std::vector&lt;int&gt;&amp; v) {
    for (auto it = v.begin(); it != v.end(); ) {
        if (*it % 2 == 0) it = v.erase(it); // 使用返回值
        else ++it;
    }
}

// 序列容器：erase-remove 惯用法
void erase_remove(std::vector&lt;int&gt;&amp; v) {
    v.erase(std::remove_if(v.begin(), v.end(), [](int x){ return x % 2 == 0; }), v.end());
}

// 关联容器：返回下一个迭代器
void erase_in_unordered(std::unordered_map&lt;int,int&gt;&amp; m) {
    for (auto it = m.begin(); it != m.end(); ) {
        if (it-&gt;first &lt; 0) it = m.erase(it); else ++it;
    }
}

// list：erase后其他迭代器有效
void erase_in_list(std::list&lt;int&gt;&amp; lst) {
    for (auto it = lst.begin(); it != lst.end(); ) {
        if (*it == 0) it = lst.erase(it); else ++it;
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片18 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">18. 完美转发（Perfect Forwarding）</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">什么是完美转发？为何需要？如何通过转发引用 + <code>std::forward</code> 保留值类别。</p>
                </div>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">要点</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>形参形如 <code>T&amp;&amp;</code> 且模板类型推导到同名T时是<strong>转发引用</strong>（不是纯右值引用）。</li>
                        <li><code>std::forward&lt;T&gt;(x)</code>：若T推导为左值引用则返回左值，否则返回右值，从而保留值类别。</li>
                        <li>典型应用：工厂/容器<strong>emplace</strong>、包装器、事件分发。</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">示例</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Foo {
    std::string s;
    Foo(const std::string&amp; x) : s(x) {}      // 拷贝构造
    Foo(std::string&amp;&amp; x) : s(std::move(x)) {} // 移动构造
};

template&lt;typename... Args&gt;
Foo make_foo(Args&amp;&amp;... args) {
    return Foo(std::forward&lt;Args&gt;(args)...); // 完美转发
}

template&lt;typename T, typename... Args&gt;
T&amp; emplace_back(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args) {
    v.emplace_back(std::forward&lt;Args&gt;(args)...);
    return v.back();
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片19 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">19. read() 从用户态到数据返回的内核路径</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">从 read 调用到数据返回的内核路径（VFS、页缓存、块层、copy_to_user）。</p>
                </div>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">核心流程（概览）</h3>
                    <ol class="list-decimal ml-5 text-gray-700 mb-2">
                        <li>用户态：libc封装触发系统调用；参数从用户栈/寄存器传入。</li>
                        <li>陷入内核：syscall入口切换到内核态，建立内核栈/pt_regs。</li>
                        <li>VFS层：根据进程<code>files_struct</code>查fd对应<code>struct file</code>，定位<code>file_operations</code>。
                        </li>
                        <li>文件系统：调用<code>vfs_read -&gt; __vfs_read -&gt; file-&gt;f_op-&gt;read_iter</code>等具体fs实现。</li>
                        <li>页缓存：先查页缓存（page cache）。命中直接拷贝；未命中触发读盘：</li>
                        <ul class="list-disc ml-6">
                            <li>生成bio请求，经块层（elevator/blk-mq）到设备驱动，DMA从设备读入页。</li>
                            <li>可能合并、预读（readahead）、调度；中断完成后唤醒等待者。</li>
                        </ul>
                        <li>拷贝到用户：<code>copy_to_user</code> 将页缓存数据拷入用户缓冲区（Direct I/O 可绕过页缓存）。</li>
                        <li>返回用户态：设置返回值（已读字节）、恢复寄存器/标志，返回用户态。</li>
                    </ol>
                    <p class="text-gray-700">
                        补充：缓存一致性、脏页回写、文件偏移更新（<code>file-&gt;f_pos</code>）、信号中断、非阻塞读、管道/套接字路径与设备驱动差异。</p>
                </div>
            </div>

            <!-- 知识点卡片20 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">20. Linux内存管理与虚拟内存的意义</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">Linux 内存管理机制概览与虚拟内存的动机。</p>
                </div>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">关键概念</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>虚拟内存：每进程独立地址空间，地址经页表由MMU映射到物理内存/交换区。</li>
                        <li>按需分页（Demand Paging）、COW、页缓存、匿名页、mmap映射。</li>
                        <li>分配器：伙伴系统（页级）+ slab/slub（小对象缓存）。</li>
                        <li>TLB 与HugeTLB：加速地址转换；透明大页（THP）。</li>
                    </ul>
                    <p class="text-gray-700"><span
                            class="font-medium">引入虚拟内存的原因：</span>隔离与保护、扩大可用地址空间、简化内存管理接口、支持内存映射文件/共享内存、提升I/O（页缓存）。</p>
                </div>
            </div>

            <!-- 知识点卡片21 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">21. 裁剪 Linux 内核：步骤与考量</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">步骤</h3>
                    <ol class="list-decimal ml-5 text-gray-700 mb-2">
                        <li>获取源码并确定目标平台（CPU、外设、文件系统、启动方式）。</li>
                        <li>以现有配置为基：<code>make oldconfig</code>，再 <code>make menuconfig</code> 关闭不必要的驱动/文件系统/调试。</li>
                        <li>选择内核特性：抢占模型、时钟源/频率、内存模型、NUMA/CPU数量、cgroup等。</li>
                        <li>编译与打包：<code>make -jN bzImage modules</code>；制作initramfs，拷贝到引导分区；更新引导器。</li>
                        <li>启动与验证：串口/串口控制台日志；逐步精简，启用必要的调试选项。</li>
                    </ol>
                </div>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">考量</h3>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>硬件支持不可缺：存储/网卡/控制台/根文件系统。</li>
                        <li>体积与启动时间vs功能：模块化与内置的权衡。</li>
                        <li>安全与调试：KASLR、SELinux、lockdep、kmemleak等开关对体积/性能影响。</li>
                        <li>升级策略：与发行版工具链/内核ABI兼容性。</li>
                    </ul>
                </div>
            </div>

            <!-- 知识点卡片22 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">22. Linux 文件系统：原理与管理</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">概览</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>VFS 抽象：统一的inode/dentry/super_block接口；具体实现如 ext4、xfs、btrfs。</li>
                        <li>inode：元数据（权限、大小、时间戳、数据块指针/extent）。</li>
                        <li>dentry：目录项缓存，加速路径解析（dcache）。</li>
                        <li>页缓存与回写：提高读写性能；脏页由回写线程刷盘；日志文件系统提供崩溃一致性。</li>
                    </ul>
                    <p class="text-gray-700">ext4 采用extent、延迟分配、日志；目录采用HTree；quota、ACL、xattr 支持。</p>
                </div>
            </div>

            <!-- 知识点卡片23 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">23. 编译器与连接器的职责</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">答案</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span
                                class="font-medium">编译器（Compiler）：</span>将源代码翻译为目标文件（.o），包含词法/语法/语义分析、优化、中间表示、生成汇编，随后经汇编器生成机器码。
                        </li>
                        <li><span
                                class="font-medium">连接器（Linker）：</span>将多个目标文件与库合并为可执行/共享库，完成符号解析、重定位、合并节、解决依赖、处理初始化/构造器节，生成可装载文件。
                        </li>
                        <li>运行时加载器（ld-linux）：装载ELF、执行动态重定位、解析依赖库、运行初始化段。</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">命令示例</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># 1) 编译为目标文件
gcc -c a.c b.c   # 生成 a.o b.o

# 2) 连接生成可执行文件，并导出链接映射
gcc a.o b.o -o app -Wl,-Map=app.map

# 3) 观察节/符号/依赖
readelf -S app | less
nm -C app | head
ldd app</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片24 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">24. 状态机（State Machine）实现方案</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">常见方案</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>switch/enum 驱动的状态转移（轻量、直观）。</li>
                        <li>表驱动（转移表/函数表），易扩展、可数据化。</li>
                        <li>面向对象的状态模式（State Pattern），每个状态独立类，易维护。</li>
                        <li>基于事件循环与回调/协程的异步状态机，配合计时器/IO事件。</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">示例：表驱动状态机</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="cpp p-4 text-sm overflow-x-auto">#include &lt;functional&gt;
#include &lt;unordered_map&gt;

enum class State { Idle, Running, Stopped };
enum class Event { Start, Stop, Reset };

struct FSM {
    State s{State::Idle};
    using Action = std::function&lt;void()&gt;;
    std::unordered_map&lt;long, std::pair&lt;State, Action&gt;&gt; trans;

    static long key(State s, Event e) { return (long)s * 10 + (long)e; }
    void add(State from, Event e, State to, Action a) { trans[key(from,e)] = {to, std::move(a)}; }
    void on(Event e) {
        auto it = trans.find(key(s,e));
        if (it != trans.end()) { auto [to, act] = it-&gt;second; if (act) act(); s = to; }
    }
};</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片25 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">25. 程序在什么情况下会产生 Core Dump？</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">常见触发</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>SIGSEGV（非法地址访问）、SIGABRT（abort/断言失败）、SIGFPE（算术错误）、SIGILL（非法指令）、SIGBUS（总线错误）。</li>
                        <li>栈溢出、双重释放/野指针解引用、越界访问、数据竞争导致的未定义行为。</li>
                        <li>ulimit/core_pattern 设置允许生成核心转储。</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">快速检查与启用</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># 临时开启当前会话 core dump（无限制）
ulimit -c unlimited

# 查看/设置 core 文件命名规则
cat /proc/sys/kernel/core_pattern
echo "/tmp/core.%e.%p.%t" | sudo tee /proc/sys/kernel/core_pattern

# 运行程序并在崩溃后用 gdb 分析
./app
gdb ./app /tmp/core.app.12345.1699999999</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片26 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">26. Core Dump 的定位与分析流程</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">步骤</h3>
                    <ol class="list-decimal ml-5 text-gray-700 mb-2">
                        <li>开启核心转储：<code>ulimit -c unlimited</code>；配置<code>/proc/sys/kernel/core_pattern</code>。</li>
                        <li>使用调试信息构建（-g，关闭优化或降级优化便于阅读）。</li>
                        <li>加载分析：<code>gdb ./prog core.x</code>；查看
                            <code>bt</code>、<code>thread apply all bt</code>、<code>info locals</code>、<code>p var</code>。
                        </li>
                        <li>符号与地址：<code>info files</code>、<code>info sharedlibrary</code>；<code>addr2line</code>
                            对无符号库定位。</li>
                        <li>复现场景：根据调用栈/日志/监控重放输入；加入ASAN/UBSAN提升发现率。</li>
                    </ol>
                </div>
            </div>

            <!-- 知识点卡片27 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="performance">
                <h2 class="text-xl font-bold mb-4 text-primary">27. 性能调优思路与常用工具</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">思路</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>目标明确：SLO/指标；建立基线；可测可复现。</li>
                        <li>定位瓶颈：CPU/内存/IO/锁/网络；先系统级（perf/top/iostat）、再进程级（perf record/FlameGraph）。</li>
                        <li>验证迭代：一次只改一处，压测验证；对比前后。</li>
                    </ul>
                </div>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">工具</h3>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>perf、bcc/eBPF（funclatency, offcputime）、FlameGraph。</li>
                        <li>valgrind/callgrind、gperftools、heaptrack；ASAN/TSAN/UBSAN。</li>
                        <li>网络：ss/tcpdump/sar；存储：iostat/blktrace；锁：perf lock/sched。</li>
                    </ul>
                </div>
            </div>

            <!-- 知识点卡片28 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">28. 使用 GDB 调试多线程程序</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">常用操作</h3>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">复制</button>
                        <pre><code class="bash p-4 text-sm overflow-x-auto"># 附加或启动
gdb -p &lt;pid&gt;
gdb --args ./app arg1 arg2

# 线程查看与切换
(gdb) info threads
(gdb) thread apply all bt
(gdb) thread &lt;tid&gt;
(gdb) bt

# 只运行当前线程（便于复现竞争）
(gdb) set scheduler-locking on

# 观察变量/断点
(gdb) watch var
(gdb) break file.cpp:123
(gdb) continue</code></pre>
                    </div>
                </div>
            </div>

            <!-- 知识点卡片29 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">29. NUMA 与非NUMA的区别与优势</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">答案</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span class="font-medium">非NUMA（UMA）：</span>所有CPU访问内存延迟均匀；规模扩展受限。</li>
                        <li><span class="font-medium">NUMA：</span>内存分为结点（近/远内存），本地访问低延迟、高带宽，远端代价更高。</li>
                        <li><span class="font-medium">优势：</span>可横向扩展；就近分配提高缓存命中与带宽利用。</li>
                        <li>优化：<code>numactl</code>策略、线程绑核、<span
                                class="font-medium">first-touch</span>分配、跨NUMA分片、减少跨结点共享。</li>
                    </ul>
                </div>
            </div>

            <!-- 知识点卡片30 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="interview">
                <h2 class="text-xl font-bold mb-4 text-primary">30. 三层缓存的大致延迟</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">参考量级（不同CPU会有差异）</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li>L1：~1ns（~4 个周期）</li>
                        <li>L2：~3–4ns（~12 个周期）</li>
                        <li>L3：~10–20ns（~30–60 个周期，与共享/拓扑相关）</li>
                        <li>内存（DRAM）：~60–120ns（几十到上百个周期）</li>
                    </ul>
                    <p class="text-gray-700">优化方向：提高局部性（数据/指令）、预取、减少跨核/跨NUMA访问、合并访问、向量化、避免伪共享。</p>
                </div>
            </div>

            <!-- 知识点卡片31 -->
            <div class="card bg-white rounded-lg p-6 card-shadow card-hover" data-category="performance">
                <h2 class="text-xl font-bold mb-4 text-primary">31. 介绍 NUMA（非一致内存访问）</h2>
                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">问题描述</h3>
                    <p class="text-gray-700">简要介绍 NUMA 的概念、与 UMA 的区别、为何会出现 NUMA、以及在软件层面的影响与常见优化策略。</p>
                </div>

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-2">核心要点</h3>
                    <ul class="list-disc ml-5 text-gray-700 mb-2">
                        <li><span class="font-medium">NUMA 概念：</span>Non-Uniform Memory
                            Access，系统内存被划分为多个节点（node）；每个节点有自己的本地内存，部分 CPU 对本地内存访问延迟低、带宽高，对远端节点访问则延迟更高。</li>
                        <li><span class="font-medium">与 UMA 的区别：</span>UMA（Uniform Memory Access）中所有 CPU
                            访问内存的延迟/带宽均匀；NUMA 为了扩展性将内存与 CPU 绑定到不同节点，带来非均匀访问特性。</li>
                        <li><span class="font-medium">出现原因：</span>多处理器/多套接字系统为提高内存带宽与扩展性，将内存物理上分配在靠近各个处理器的内存控制器上，从而形成
                            NUMA 拓扑。</li>
                        <li><span class="font-medium">软件影响：</span>线程/进程应尽量访问本地内存以减少远程访问延迟；不当的内存分配或线程调度会引起频繁跨节点访问，导致性能降低。
                        </li>
                    </ul>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">常见优化与工具</h3>
                    <ul class="list-disc ml-5 text-gray-700">
                        <li>绑定线程到 CPU（pthread_setaffinity_np / taskset / numactl --physcpubind）以保持计算与数据局部性。</li>
                        <li>first-touch 分配策略：让首次访问页面的线程将内存分配到其本地 NUMA 节点。</li>
                        <li>使用 <code>numactl</code> 和 <code>libnuma</code> 控制/查询 NUMA 拓扑、策略与内存分配。</li>
                        <li>为大数据结构进行跨节点分片或复制，减少跨节点同步与缓存竞争（例如按节点划分工作集）。</li>
                        <li>避免伪共享；利用 HugePages/hugeTLB 在适当场景下降低 TLB 压力并提升带宽。</li>
                        <li>性能分析：使用 <code>numastat</code>、<code>perf</code>、<code>pcm</code> 等工具定位远程内存访问与带宽瓶颈。</li>
                    </ul>
                </div>
            </div>
        </div>
    </main>

    <script>
        // 过滤功能
        document.addEventListener('DOMContentLoaded', function () {
            const filterButtons = document.querySelectorAll('.filter-btn');
            const cards = document.querySelectorAll('.card');

            filterButtons.forEach(button => {
                button.addEventListener('click', function () {
                    const filter = this.getAttribute('data-filter');

                    // 更新按钮状态
                    filterButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');

                    // 过滤卡片
                    cards.forEach(card => {
                        if (filter === 'all' || card.getAttribute('data-category') === filter) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                });
            });
        });

        // 滚动时增强导航阴影与背景不透明度
        document.addEventListener('scroll', function () {
            const header = document.querySelector('header');
            if (!header) return;
            if (window.scrollY > 8) header.classList.add('scrolled');
            else header.classList.remove('scrolled');
        });

        // 复制代码功能
        function copyCode(button) {
            const codeBlock = button.parentElement;
            const code = codeBlock.querySelector('code');
            const text = code.textContent || code.innerText;

            navigator.clipboard.writeText(text).then(function () {
                button.textContent = '已复制';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = '复制';
                    button.classList.remove('copied');
                }, 2000);
            }).catch(function (err) {
                console.error('复制失败:', err);
            });
        }
    </script>
</body>

</html>